<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Plasma Bulk Sender</title>
<style>
  :root{
    --bg:#0A1512; --panel:#162F29; --muted:#9fb0d9; --text:#E9F1EE;
    --accent:#569F8C; --accent2:#5986C5; --danger:#ff6b6b; --ok:#10b981; --border:#1f3a33; --radius:16px;
  }
  *{box-sizing:border-box}
  body{margin:0; background:linear-gradient(180deg,#0A1512,#0C1916 35%,#0A1512); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:980px; margin:40px auto; padding:0 16px}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:var(--radius); padding:20px; box-shadow:0 10px 40px rgba(0,0,0,.35)}
  h1{font-size:28px; margin:0 0 8px}
  .sub{color:var(--muted); margin-bottom:18px}
  .row{display:flex; gap:16px; flex-wrap:wrap}
  .col{flex:1 1 320px; min-width:280px}
  label{display:block; color:#cde3de; margin:10px 0 6px; font-size:14px}
  select,textarea,input[type="text"]{width:100%; background:#0E221D; border:1px solid #1C3E36; border-radius:12px; color:var(--text); padding:12px 14px; outline:none}
  textarea{min-height:200px; line-height:1.35; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace}
  .btn{display:inline-flex; align-items:center; gap:8px; padding:12px 16px; border-radius:12px; border:1px solid #1A3A34; cursor:pointer; color:white; background:linear-gradient(135deg,var(--accent),var(--accent2)); transition:transform .05s ease,filter .2s}
  .btn:active{transform:translateY(1px)} .btn.secondary{background:#143027; border-color:#224D43}
  .btn[disabled]{filter:grayscale(1) brightness(.75); cursor:not-allowed}
  .stack{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .pill{padding:6px 10px; border-radius:999px; background:#0F241F; border:1px solid #1C3E36; color:#c6dfda; font-size:12px}
  .log{background:#0A1F1A; border:1px dashed #245045; color:#c6dfda; padding:12px; border-radius:12px; min-height:160px; white-space:pre-wrap}
  .filebox{padding:10px 12px; border:1px dashed #245045; border-radius:12px; background:#0E221D; color:#c6dfda}
  .footer{margin-top:14px; color:#b8ccc7; font-size:12px}
  a,a:visited{color:#79BFB0; text-decoration:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Plasma Bulk Sender</h1>
    <div class="sub">Send native XPL or ERC-20 tokens to many recipients. Paste <code>address,amount</code> lines or upload a CSV.</div>

    <div class="row" style="margin-bottom:12px">
      <div class="col">
        <div class="stack">
          <button id="btnConnect" class="btn">Connect Wallet</button>
          <span id="status" class="pill">Not connected</span>
        </div>
        <div style="margin-top:10px; font-size:13px; color:#c6dfda">
          Chain: <span id="chainName">Plasma</span> •
          Contract: <a id="contractLink" href="#" target="_blank">—</a>
        </div>
      </div>
      <div class="col">
        <label>Token</label>
        <select id="tokenSelect">
          <option value="native">XPL (Native)</option>
          <option value="USDT0">USDT0</option>
          <option value="sUSDe">sUSDe</option>
          <option value="USDe">USDe</option>
          <option value="WETH">WETH</option>
          <option value="weETH">weETH</option>
          <option value="syrupUSDT">syrupUSDT</option>
          <option value="waPlaUSDT0">waPlaUSDT0</option>
          <option value="USDai">USDai</option>
          <option value="xUSD">xUSD</option>
          <option value="wstUSR">wstUSR</option>
          <option value="WXPL">WXPL</option>
          <option value="XAUt0">XAUt0</option>
          <option value="sUSDai">sUSDai</option>
          <option value="CUSTOM">Custom ERC-20 (enter address)</option>
        </select>
        <div id="customTokenWrap" style="display:none; margin-top:8px">
          <input id="customToken" type="text" placeholder="0x… (ERC-20 address)" />
        </div>

        <div style="margin-top:8px">
          <label style="display:flex;align-items:center;gap:8px;">
            <input id="allowFailures" type="checkbox" />
            <span>Allow partial failures (refund on failures)</span>
          </label>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col">
        <label>Addresses with Amounts</label>
        <textarea id="manual" placeholder="0x3df332e44a0bbff025838c187873d77f92caf5e9,0.001
0x76d31966abf3edeb29e599eac4adcb72fba85e6a,1
0xC8c30Fa803833dD1Fd6DBCDd91Ed0b301EFf87cF,3.45"></textarea>

        <div class="stack" style="margin-top:8px">
          <label class="filebox">
            <input id="csvFile" type="file" accept=".csv" style="display:none" />
            Upload CSV
          </label>
          <span id="csvName" class="pill">No file</span>
        </div>

        <div class="stack" style="margin-top:12px">
          <button id="btnEstimate" class="btn secondary">Estimate & Validate</button>
          <button id="btnSend" class="btn" disabled>Send</button>
          <button id="btnClear" class="btn secondary">Reset</button>
        </div>
      </div>

      <div class="col">
        <label>Log</label>
        <div id="log" class="log">Ready.</div>
        <div class="footer">
          Amounts are human units (e.g. <code>0.1</code>). We read <code>decimals()</code> automatically.
          Fee = <strong>0.10%</strong> (ceil rounded) of total in the **same asset**.
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>
<script>
/*** CONFIG (Plasma) ***/
const CONFIG = {
  CHAIN: {
    chainId: "0x2611", // 9745
    chainName: "Plasma",
    rpcUrls: ["https://rpc.plasma.to"],
    blockExplorerUrls: ["https://plasmascan.to"],
    nativeCurrency: { name: "XPL", symbol: "XPL", decimals: 18 }
  },
  CONTRACT: {
    bulkSender: "0x571452919EE2A638766AC503BFa0522B1887722c" // your deployed V3
  },
  TOKENS: {
    USDT0:      "0xB8CE59FC3717ada4C02eaDF9682A9e934F625ebb",
    sUSDe:      "0x211Cc4DD073734dA055fbF44a2b4667d5E5fE5d2",
    USDe:       "0x5d3a1Ff2b6BAb83b63cd9AD0787074081a52ef34",
    WETH:       "0x9895D81bB462A195b4922ED7De0e3ACD007c32CB",
    weETH:      "0xA3D68b74bF0528fdD07263c60d6488749044914b",
    syrupUSDT:  "0xC4374775489CB9C56003BF2C9b12495fC64F0771",
    waPlaUSDT0: "0xE0126F0c4451B2B917064A93040fd4770D6774b5",
    USDai:      "0x0A1a1A107E45b7Ced86833863f482BC5f4ed82EF",
    xUSD:       "0x6eAf19b2FC24552925dB245F9Ff613157a7dbb4C",
    wstUSR:     "0x2a52B289bA68bBd02676640aA9F605700c9e5699",
    WXPL:       "0x6100E367285b01F48D07953803A2d8dCA5D19873",
    XAUt0:      "0x1B64B9025EEbb9A6239575dF9Ea4b9Ac46D4d193",
    sUSDai:     "0x0B2b2B2076d95dda7817e785989fE353fe955ef9"
  },
  GAS: {
    targetPerTx: 7_000_000n, // heuristic, adjust if needed
    minChunk: 15,
    maxChunk: 200
  }
};

const BULK_ABI = [
  {"inputs":[{"internalType":"address[]","name":"recipients","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"sendNative","outputs":[],"stateMutability":"payable","type":"function"},
  {"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address[]","name":"recipients","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"sendERC20","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address[]","name":"recipients","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"sendERC20AllowFailures","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"uint256","name":"totalAmount","type":"uint256"}],"name":"quoteFeeOnAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
];
const ERC20_ABI = [
  {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
  {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
  {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}
];

const $ = (id)=>document.getElementById(id);
const logEl=$('log'), statusEl=$('status'), tokenSelect=$('tokenSelect'), customTokenWrap=$('customTokenWrap'), customToken=$('customToken');
const btnConnect=$('btnConnect'), btnEstimate=$('btnEstimate'), btnSend=$('btnSend'), btnClear=$('btnClear');
const manualEl=$('manual'), csvFile=$('csvFile'), csvName=$('csvName'), chainNameEl=$('chainName'), contractLinkEl=$('contractLink');
const allowFailuresEl=$('allowFailures');

let injected, provider, signer, account, chainIdHex, bulk, tokenAddr=null, tokenSymbol='XPL', tokenDecimals=18;
let parsedList = [];

chainNameEl.textContent = CONFIG.CHAIN.chainName;
(function initLink(){
  try{
    if (CONFIG.CONTRACT.bulkSender && ethers.isAddress(CONFIG.CONTRACT.bulkSender)) {
      contractLinkEl.textContent = CONFIG.CONTRACT.bulkSender.slice(0,6)+"…"+CONFIG.CONTRACT.bulkSender.slice(-4);
      contractLinkEl.href = `${CONFIG.CHAIN.blockExplorerUrls[0]}/address/${CONFIG.CONTRACT.bulkSender}`;
    }
  }catch{}
})();

const log = (m,c)=>{ logEl.textContent += (logEl.textContent?'\n':'') + (c?`[${c.toUpperCase()}] `:'') + m; logEl.scrollTop = logEl.scrollHeight; };
const setStatus = (t,c="")=>{ statusEl.textContent=t; statusEl.className="pill"+(c?(" "+c):""); };
const isAddress = (a)=>{ try { return ethers.isAddress(a); } catch { return false; } };
const toUnits = (s,d)=>ethers.parseUnits(s, d);
const sumBig = (arr)=>arr.reduce((s,x)=> s + x, 0n);
const chunkArray = (arr,size)=>{ const out=[]; for(let i=0;i<arr.length;i+=size) out.push(arr.slice(i,i+size)); return out; };

function parseLines(){
  const raw = manualEl.value.trim(); parsedList = [];
  if (!raw) return parsedList;
  for (const line of raw.split(/\r?\n/)) {
    const t = line.trim(); if (!t || t.startsWith('#') || t.startsWith('//')) continue;
    const parts = t.split(',').map(x=>x.trim());
    if (parts.length !== 2) { log(`Ignored line (use "address,amount"): "${line}"`, "warn"); continue; }
    parsedList.push({ addr: parts[0], amountDecimalStr: parts[1] });
  }
  return parsedList;
}

// Wallet discovery (EIP-6963 + fallbacks)
let discoveredProviders = [];
window.addEventListener("eip6963:announceProvider",(e)=>{ const p=e.detail?.provider; if (p && !discoveredProviders.includes(p)) discoveredProviders.push(p); });
window.dispatchEvent(new Event("eip6963:requestProvider"));
function getCandidateProviders(){
  const list=[...discoveredProviders];
  if (window.ethereum?.providers?.length) for (const p of window.ethereum.providers) if (!list.includes(p)) list.push(p);
  if (window.ethereum && !list.includes(window.ethereum)) list.push(window.ethereum);
  return list;
}
async function pickProvider(){ const cand = getCandidateProviders(); if (!cand.length) return null; const mm = cand.find(p=>p.isMetaMask); return mm || cand[0]; }

async function ensurePlasmaNetwork(p){
  try{
    const cid = await p.request({ method:"eth_chainId" });
    if (cid?.toLowerCase() === CONFIG.CHAIN.chainId.toLowerCase()) return true;
    await p.request({ method:"wallet_switchEthereumChain", params:[{ chainId: CONFIG.CHAIN.chainId }] });
    return true;
  }catch(e){
    if (e.code===4902 || /Unrecognized chain/i.test(e.message)) {
      await p.request({ method:"wallet_addEthereumChain", params:[CONFIG.CHAIN] });
      return true;
    }
    log(`Network switch failed: ${e.message}`, "warn");
    return false;
  }
}

tokenSelect.addEventListener('change', ()=>{ customTokenWrap.style.display = tokenSelect.value === 'CUSTOM' ? 'block' : 'none'; });
csvFile.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f){csvName.textContent="No file"; return;} csvName.textContent=f.name; const txt=await f.text(); manualEl.value = manualEl.value.trim() ? (manualEl.value.trim()+"\n"+txt.trim()) : txt.trim(); log(`CSV loaded: ${f.name}`); });

btnConnect.addEventListener('click', async ()=>{
  try{
    await new Promise(r=>setTimeout(r,150));
    injected = await pickProvider();
    if (!injected){ setStatus("No wallet", ""); log("No wallet provider found. Open via http://localhost:… or MetaMask in-app.", "err"); return; }
    provider = new ethers.BrowserProvider(injected, "any");
    await injected.request({ method:"eth_requestAccounts" });
    const ok = await ensurePlasmaNetwork(injected);
    if (!ok) log("Warning: wrong network – sending will fail.", "warn");

    signer = await provider.getSigner();
    account = await signer.getAddress();
    const net = await provider.getNetwork();
    chainIdHex = "0x"+net.chainId.toString(16);
    setStatus(`Connected: ${account.slice(0,6)}…${account.slice(-4)}`, "ok");

    if (!ethers.isAddress(CONFIG.CONTRACT.bulkSender)) {
      log("Set your Bulk Sender contract address in CONFIG.CONTRACT.bulkSender.", "warn");
    } else {
      bulk = new ethers.Contract(CONFIG.CONTRACT.bulkSender, BULK_ABI, signer);
      contractLinkEl.textContent = CONFIG.CONTRACT.bulkSender.slice(0,6)+"…"+CONFIG.CONTRACT.bulkSender.slice(-4);
      contractLinkEl.href = `${CONFIG.CHAIN.blockExplorerUrls[0]}/address/${CONFIG.CONTRACT.bulkSender}`;
    }
    injected.on?.("accountsChanged", ()=>location.reload());
    injected.on?.("chainChanged", ()=>location.reload());
  }catch(e){ setStatus("Connect failed",""); log(`ERROR Connect: ${e.message}`,"err"); }
});

async function resolveToken(){
  const choice = tokenSelect.value;
  if (choice === 'native'){ tokenAddr=null; tokenSymbol='XPL'; tokenDecimals=CONFIG.CHAIN.nativeCurrency.decimals; return; }
  if (choice in CONFIG.TOKENS){
    tokenAddr = CONFIG.TOKENS[choice]; tokenSymbol = choice;
  } else if (choice === 'CUSTOM') {
    const addr = customToken.value.trim();
    if (!isAddress(addr)) throw new Error("Custom ERC-20 address invalid.");
    tokenAddr = addr; tokenSymbol = "ERC20";
  }
  // decimals & symbol best-effort
  try{
    const erc20 = new ethers.Contract(tokenAddr, [
      {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}
    ], provider);
    tokenDecimals = Number(await erc20.decimals());
    try{ tokenSymbol = await erc20.symbol(); }catch{}
  }catch{ tokenDecimals = 18; }
}

async function estimateChunkGas(recipients, amounts, isNative){
  try{
    if (isNative){
      const total = amounts.reduce((s,x)=>s + x, 0n);
      const fee = await bulk.quoteFeeOnAmount(total);
      return await bulk.sendNative.estimateGas(recipients, amounts, { value: total + fee });
    } else {
      return await bulk.sendERC20.estimateGas(tokenAddr, recipients, amounts);
    }
  }catch{ return null; }
}

function cap(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
async function pickChunkSize(recipients, amounts, isNative){
  let lo=CONFIG.GAS.minChunk, hi=Math.min(CONFIG.GAS.maxChunk, recipients.length);
  let best=Math.min(hi,100);
  while (lo<=hi){
    const mid=cap(Math.floor((lo+hi)/2), lo, hi);
    const r=recipients.slice(0,mid), a=amounts.slice(0,mid);
    const gas=await estimateChunkGas(r,a,isNative);
    if (gas && gas <= CONFIG.GAS.targetPerTx){ best=mid; lo=mid+1; } else { hi=mid-1; }
  }
  if (!best || best<CONFIG.GAS.minChunk) best=Math.min(50, recipients.length);
  return cap(best, CONFIG.GAS.minChunk, CONFIG.GAS.maxChunk);
}

btnEstimate.addEventListener('click', async ()=>{
  try{
    if (!signer) throw new Error("Connect your wallet first.");
    if (!bulk) throw new Error("Set Bulk Sender address in config and reconnect.");

    parseLines();
    if (parsedList.length===0) throw new Error("No recipients found.");
    for (const {addr, amountDecimalStr} of parsedList){
      if (!isAddress(addr)) throw new Error(`Invalid address: ${addr}`);
      if (!/^\d+(\.\d+)?$/.test(amountDecimalStr)) throw new Error(`Invalid amount: ${amountDecimalStr}`);
    }
    await resolveToken();

    const recipients = parsedList.map(x=>x.addr);
    const amounts    = parsedList.map(x=>toUnits(x.amountDecimalStr, tokenDecimals));
    const total      = sumBig(amounts);
    const isNative   = !tokenAddr;

    const fee = await bulk.quoteFeeOnAmount(total);
    const humanTotal = isNative?ethers.formatEther(total):ethers.formatUnits(total, tokenDecimals);
    const humanFee   = isNative?ethers.formatEther(fee)  :ethers.formatUnits(fee, tokenDecimals);
    log(`Totals → amount: ${humanTotal} ${isNative?'XPL':tokenSymbol} | fee: ${humanFee} ${isNative?'XPL':tokenSymbol}`);

    // balance hints
    if (isNative){
      const bal = await provider.getBalance(await signer.getAddress());
      if (bal < (total + fee)) log(`WARN: XPL balance < total+fee (${ethers.formatEther(total+fee)} XPL needed)`, "warn");
    } else {
      const erc20 = new ethers.Contract(tokenAddr, [{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}], signer);
      const me = await signer.getAddress();
      const bal = await erc20.balanceOf(me);
      if (bal < (total + fee)) log(`WARN: ${tokenSymbol} balance < total+fee (${ethers.formatUnits(total+fee, tokenDecimals)} ${tokenSymbol} needed)`, "warn");
    }

    const chunkSize = await pickChunkSize(recipients, amounts, isNative);
    log(`Validation OK: ${recipients.length} recipients | Token=${isNative?"XPL (native)":tokenSymbol} | Decimals=${tokenDecimals}`);
    log(`Auto-chunking: ${chunkSize} recipients/tx (target gas ~${CONFIG.GAS.targetPerTx})`);
    btnSend.disabled = false;
    btnSend.dataset.chunkSize = String(chunkSize);
    setStatus("Ready to send", "ok");
  }catch(e){
    btnSend.disabled = true;
    setStatus("Validation error", "");
    log(`ERROR (Estimate): ${e.message}`, "err");
  }
});

btnSend.addEventListener('click', async ()=>{
  try{
    if (!signer || !bulk) throw new Error("Not connected / contract missing.");
    await resolveToken();
    parseLines();

    const recipients = parsedList.map(x=>x.addr);
    const amounts    = parsedList.map(x=>toUnits(x.amountDecimalStr, tokenDecimals));
    const total      = sumBig(amounts);
    const isNative   = !tokenAddr;
    const chunkSize  = Math.max(CONFIG.GAS.minChunk, parseInt(btnSend.dataset.chunkSize || "80", 10));
    const chunksR = chunkArray(recipients, chunkSize);
    const chunksA = chunkArray(amounts, chunkSize);

    if (isNative){
      for (let i=0;i<chunksR.length;i++){
        const r=chunksR[i], a=chunksA[i];
        const subtotal = a.reduce((s,x)=>s + x, 0n);
        const fee      = await bulk.quoteFeeOnAmount(subtotal);
        log(`Sending native chunk ${i+1}/${chunksR.length} … need value=${ethers.formatEther(subtotal+fee)} XPL`);
        const tx = await bulk.sendNative(r, a, { value: subtotal + fee });
        log(`Tx sent: ${tx.hash}`); await tx.wait(); log(`Tx confirmed ✅`);
      }
    } else {
      const useAllow = !!allowFailuresEl.checked;
      if (useAllow){
        // Approve max (total + feeMax) once; contract refundet Überschuss
        const feeMax = await bulk.quoteFeeOnAmount(total);
        const erc20 = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
        log(`Approving ${ethers.formatUnits(total+feeMax, tokenDecimals)} ${tokenSymbol} (allow-failures)…`);
        const txA = await erc20.approve(CONFIG.CONTRACT.bulkSender, total + feeMax);
        await txA.wait(); log(`Approve confirmed: ${txA.hash}`);

        // Kein Chunking, weil Refunds einfacher pro Batch sind
        log(`Sending ERC-20 (allow failures) batch of ${recipients.length} …`);
        const tx = await bulk.sendERC20AllowFailures(tokenAddr, recipients, amounts);
        log(`Tx sent: ${tx.hash}`); await tx.wait(); log(`Tx confirmed ✅ (contract refunded any failures)`);
      } else {
        // Atomic path: chunked
        const fee = await bulk.quoteFeeOnAmount(total);
        const erc20 = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
        log(`Approving ${ethers.formatUnits(total+fee, tokenDecimals)} ${tokenSymbol} (atomic)…`);
        const txA = await erc20.approve(CONFIG.CONTRACT.bulkSender, total + fee);
        await txA.wait(); log(`Approve confirmed: ${txA.hash}`);

        for (let i=0;i<chunksR.length;i++){
          const r=chunksR[i], a=chunksA[i];
          log(`Sending ERC-20 chunk ${i+1}/${chunksR.length} (${r.length} recipients)…`);
          const tx = await bulk.sendERC20(tokenAddr, r, a);
          log(`Tx sent: ${tx.hash}`); await tx.wait(); log(`Tx confirmed ✅`);
        }
      }
    }
    setStatus("Done", "ok");
    log("All done ✅✅✅");
  }catch(e){
    setStatus("Send error", "");
    log(`ERROR (Send): ${e.message}`, "err");
  }
});

btnClear.addEventListener('click', ()=>{
  manualEl.value=""; csvFile.value=""; csvName.textContent="No file"; btnSend.disabled=true; log("Reset.");
});
</script>
</body>
</html>
