<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Plasma Bulk Sender</title>
<style>
  :root{
    --bg:#0A1512; --panel:#162F29; --muted:#9fb0d9; --text:#E9F1EE;
    --accent:#569F8C; --accent2:#5986C5; --danger:#ff6b6b; --ok:#10b981; --border:#1f3a33; --radius:16px;
  }
  *{box-sizing:border-box}
  body{margin:0; background:linear-gradient(180deg,#0A1512,#0C1916 35%,#0A1512); color:var(--text); font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:980px; margin:40px auto; padding:0 16px}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:var(--radius); padding:20px; box-shadow:0 10px 40px rgba(0,0,0,.35)}
  h1{font-size:28px; margin:0 0 8px}
  .sub{color:var(--muted); margin-bottom:18px}
  .row{display:flex; gap:16px; flex-wrap:wrap}
  .col{flex:1 1 320px; min-width:280px}
  label{display:block; color:#cde3de; margin:10px 0 6px; font-size:14px}
  select,textarea,input[type="text"]{width:100%; background:#0E221D; border:1px solid #1C3E36; border-radius:12px; color:var(--text); padding:12px 14px; outline:none}
  textarea{min-height:200px; line-height:1.35; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,monospace}
  .btn{display:inline-flex; align-items:center; gap:8px; padding:12px 16px; border-radius:12px; border:1px solid #1A3A34; cursor:pointer; color:white; background:linear-gradient(135deg,var(--accent),var(--accent2)); transition:transform .05s ease,filter .2s}
  .btn:active{transform:translateY(1px)} .btn.secondary{background:#143027; border-color:#224D43}
  .btn[disabled]{filter:grayscale(1) brightness(.75); cursor:not-allowed}
  .stack{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .status-panel{background:#0A1F1A; border:1px solid #245045; border-radius:12px; padding:12px 14px; min-height:100px}
  .status-title{font-size:14px; color:#bfe0d9; margin-bottom:6px; opacity:.95}
  .status-msg{font-size:15px; line-height:1.35; color:#e4faf5; white-space:pre-wrap}
  .status-ok{color:#a7f3d0}
  .status-warn{color:#fde68a}
  .status-err{color:#fecaca}
  .log{background:#0A1F1A; border:1px dashed #245045; color:#c6dfda; padding:12px; border-radius:12px; min-height:160px; white-space:pre-wrap}
  .filebox{padding:10px 12px; border:1px dashed #245045; border-radius:12px; background:#0E221D; color:#c6dfda}
  .footer{margin-top:14px; color:#b8ccc7; font-size:12px}
  a,a:visited{color:#79BFB0; text-decoration:none}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Plasma Bulk Sender</h1>
    <div class="sub">Send native XPL or ERC-20 tokens to many recipients. Paste <code>address,amount</code> lines or upload a CSV.</div>

    <div class="row" style="margin-bottom:12px">
      <div class="col">
        <div class="stack">
          <button id="btnConnect" class="btn">Connect Wallet</button>
        </div>
        <div style="margin-top:10px; font-size:13px; color:#c6dfda">
          Chain: <span id="chainName">Plasma</span> •
          Contract: <a id="contractLink" href="#" target="_blank">—</a>
        </div>
      </div>

      <div class="col">
        <label>Token</label>
        <select id="tokenSelect">
          <option value="native">XPL (Native)</option>
          <option value="USDT0">USDT0</option>
          <option value="sUSDe">sUSDe</option>
          <option value="USDe">USDe</option>
          <option value="WETH">WETH</option>
          <option value="weETH">weETH</option>
          <option value="syrupUSDT">syrupUSDT</option>
          <option value="waPlaUSDT0">waPlaUSDT0</option>
          <option value="USDai">USDai</option>
          <option value="xUSD">xUSD</option>
          <option value="wstUSR">wstUSR</option>
          <option value="WXPL">WXPL</option>
          <option value="XAUt0">XAUt0</option>
          <option value="sUSDai">sUSDai</option>
          <option value="CUSTOM">Custom ERC-20 (enter address)</option>
        </select>
        <div id="customTokenWrap" style="display:none; margin-top:8px">
          <input id="customToken" type="text" placeholder="0x… (ERC-20 address)" />
        </div>

        <div style="margin-top:8px">
          <label style="display:flex;align-items:center;gap:8px;">
            <input id="allowFailures" type="checkbox" />
            <span>Allow partial failures (refund on failures)</span>
          </label>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col">
        <label>Addresses with Amounts</label>
        <textarea id="manual" placeholder="0x3df332e44a0bbff025838c187873d77f92caf5e9,0.001
0x76d31966abf3edeb29e599eac4adcb72fba85e6a,1
0xC8c30Fa803833dD1Fd6DBCDd91Ed0b301EFf87cF,3.45"></textarea>

        <div class="stack" style="margin-top:8px">
          <label class="filebox">
            <input id="csvFile" type="file" accept=".csv" style="display:none" />
            Upload CSV
          </label>
          <span id="csvName" class="status-msg" style="font-size:12px; opacity:.8">No file</span>
        </div>

        <div class="stack" style="margin-top:12px">
          <button id="btnEstimate" class="btn secondary">Estimate & Validate</button>
          <button id="btnSend" class="btn" disabled>Send</button>
          <button id="btnClear" class="btn secondary">Reset</button>
        </div>
      </div>

      <div class="col">
        <div class="status-panel">
          <div class="status-title">Status</div>
          <div id="statusMsg" class="status-msg">Not connected.</div>
        </div>

        <label style="margin-top:14px">Log</label>
        <div id="log" class="log">Ready.</div>

        <div class="footer">
          Amounts are human units (e.g. 0.1). For ERC-20, we read <code>decimals()</code> and convert precisely.
          Auto-chunking sizes each transaction to fit a target gas budget. There is a small fee of <strong>0.10%</strong> for using this service.
        </div>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/ethers@6.13.4/dist/ethers.umd.min.js"></script>
<script>
/*** CONFIG (Plasma) ***/
const CONFIG = {
  CHAIN: {
    chainId: "0x2611", // 9745
    chainName: "Plasma",
    rpcUrls: ["https://rpc.plasma.to"],
    blockExplorerUrls: ["https://plasmascan.to"],
    nativeCurrency: { name: "XPL", symbol: "XPL", decimals: 18 }
  },
  CONTRACT: {
    bulkSender: "0x571452919EE2A638766AC503BFa0522B1887722c"
  },
  TOKENS: {
    USDT0:      "0xB8CE59FC3717ada4C02eaDF9682A9e934F625ebb",
    sUSDe:      "0x211Cc4DD073734dA055fbF44a2b4667d5E5fE5d2",
    USDe:       "0x5d3a1Ff2b6BAb83b63cd9AD0787074081a52ef34",
    WETH:       "0x9895D81bB462A195b4922ED7De0e3ACD007c32CB",
    weETH:      "0xA3D68b74bF0528fdD07263c60d6488749044914b",
    syrupUSDT:  "0xC4374775489CB9C56003BF2C9b12495fC64F0771",
    waPlaUSDT0: "0xE0126F0c4451B2B917064A93040fd4770D6774b5",
    USDai:      "0x0A1a1A107E45b7Ced86833863f482BC5f4ed82EF",
    xUSD:       "0x6eAf19b2FC24552925dB245F9Ff613157a7dbb4C",
    wstUSR:     "0x2a52B289bA68bBd02676640aA9F605700c9e5699",
    WXPL:       "0x6100E367285b01F48D07953803A2d8dCA5D19873",
    XAUt0:      "0x1B64B9025EEbb9A6239575dF9Ea4b9Ac46D4d193",
    sUSDai:     "0x0B2b2B2076d95dda7817e785989fE353fe955ef9"
  },
  GAS: {
    targetPerTx: 7_000_000n,
    minChunk: 15,
    maxChunk: 200
  }
};

const BULK_ABI = [
  {"inputs":[{"internalType":"address[]","name":"recipients","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"sendNative","outputs":[],"stateMutability":"payable","type":"function"},
  {"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address[]","name":"recipients","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"sendERC20","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"address[]","name":"recipients","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"name":"sendERC20AllowFailures","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"uint256","name":"totalAmount","type":"uint256"}],"name":"quoteFeeOnAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}
];
const ERC20_ABI = [
  {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
  {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
  {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}
];

const $ = (id)=>document.getElementById(id);
const statusMsg=$('statusMsg'), tokenSelect=$('tokenSelect'), customTokenWrap=$('customTokenWrap'), customToken=$('customToken');
const btnConnect=$('btnConnect'), btnEstimate=$('btnEstimate'), btnSend=$('btnSend'), btnClear=$('btnClear');
const manualEl=$('manual'), csvFile=$('csvFile'), csvName=$('csvName'), chainNameEl=$('chainName'), contractLinkEl=$('contractLink');
const allowFailuresEl=$('allowFailures'), logEl=$('log');

let provider, signer, account, bulk, tokenAddr=null, tokenSymbol='XPL', tokenDecimals=18;
let parsedList = [];

chainNameEl.textContent = CONFIG.CHAIN.chainName;
(function initLink(){
  try{
    if (CONFIG.CONTRACT.bulkSender && ethers.isAddress(CONFIG.CONTRACT.bulkSender)) {
      contractLinkEl.textContent = CONFIG.CONTRACT.bulkSender.slice(0,6)+"…"+CONFIG.CONTRACT.bulkSender.slice(-4);
      contractLinkEl.href = `${CONFIG.CHAIN.blockExplorerUrls[0]}/address/${CONFIG.CONTRACT.bulkSender}`;
    }
  }catch{}
})();

const log = (m,c)=>{ 
  logEl.textContent += (logEl.textContent?'\n':'') + (c?`[${c.toUpperCase()}] `:'') + m; 
  logEl.scrollTop = logEl.scrollHeight; 
};
const setStatus = (text, level="")=>{ 
  statusMsg.textContent = text; 
  statusMsg.classList.remove('status-ok','status-warn','status-err');
  if (level) statusMsg.classList.add(`status-${level}`);
};
const isAddress = (a)=>{ try { return ethers.isAddress(a); } catch { return false; } };
const toUnits = (s,d)=>ethers.parseUnits(s, d);
const sumBig = (arr)=>arr.reduce((s,x)=> s + x, 0n);
const chunkArray = (arr,size)=>{ const out=[]; for(let i=0;i<arr.length;i+=size) out.push(arr.slice(i,i+size)); return out; };
const short = (addr)=> addr.slice(0,6) + "…" + addr.slice(-4);

/** Simplified provider detection **/
function detectProvider(){
  if (window.ethereum?.providers?.length) {
    const mm = window.ethereum.providers.find(p=>p && p.isMetaMask);
    return mm || window.ethereum.providers[0];
  }
  if (window.ethereum) return window.ethereum;
  return null;
}

async function ensurePlasmaNetwork(eth){
  try{
    const chainId = await eth.request({ method:"eth_chainId" });
    if ((chainId||"").toLowerCase() === CONFIG.CHAIN.chainId.toLowerCase()) return true;
    await eth.request({ method:"wallet_switchEthereumChain", params:[{ chainId: CONFIG.CHAIN.chainId }] });
    return true;
  }catch(e){
    if (e.code===4902 || /Unrecognized chain/i.test(e.message)) {
      await eth.request({ method:"wallet_addEthereumChain", params:[CONFIG.CHAIN] });
      return true;
    }
    throw e;
  }
}

tokenSelect.addEventListener('change', ()=>{ customTokenWrap.style.display = tokenSelect.value === 'CUSTOM' ? 'block' : 'none'; });
csvFile.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f){csvName.textContent="No file"; return;} csvName.textContent=f.name; const txt=await f.text(); manualEl.value = manualEl.value.trim() ? (manualEl.value.trim()+"\n"+txt.trim()) : txt.trim(); log(`CSV loaded: ${f.name}`); });

btnConnect.addEventListener('click', async ()=>{
  try{
    const eth = detectProvider();
    if (!eth) { setStatus("No wallet provider found (MetaMask, Rabby, etc.).","err"); log("No wallet provider found. Open via http(s) and in a wallet-enabled browser.","err"); return; }

    // Request accounts
    await eth.request({ method:"eth_requestAccounts" });

    // Ensure Plasma network
    await ensurePlasmaNetwork(eth);

    // Wire ethers
    provider = new ethers.BrowserProvider(eth, "any");
    signer = await provider.getSigner();
    account = await signer.getAddress();

    // Instantiate contract
    if (!ethers.isAddress(CONFIG.CONTRACT.bulkSender)) {
      setStatus("Contract address missing in config.","warn");
      log("Set your Bulk Sender contract address in CONFIG.CONTRACT.bulkSender.","warn");
    } else {
      bulk = new ethers.Contract(CONFIG.CONTRACT.bulkSender, BULK_ABI, signer);
      contractLinkEl.textContent = CONFIG.CONTRACT.bulkSender.slice(0,6)+"…"+CONFIG.CONTRACT.bulkSender.slice(-4);
      contractLinkEl.href = `${CONFIG.CHAIN.blockExplorerUrls[0]}/address/${CONFIG.CONTRACT.bulkSender}`;
    }

    // UI feedback
    setStatus(`Connected: ${short(account)}`, "ok");
    btnConnect.textContent = `Connected: ${short(account)}`;

    // Handle changes (simple full reload to keep state consistent)
    eth.on?.("accountsChanged", ()=>location.reload());
    eth.on?.("chainChanged", ()=>location.reload());

  }catch(e){
    setStatus(`Connect failed: ${e.message || e}`, "err");
    log(`ERROR Connect: ${e.message || e}`, "err");
  }
});

async function resolveToken(){
  const choice = tokenSelect.value;
  if (choice === 'native'){ tokenAddr=null; tokenSymbol='XPL'; tokenDecimals=CONFIG.CHAIN.nativeCurrency.decimals; return; }
  if (choice in CONFIG.TOKENS){
    tokenAddr = CONFIG.TOKENS[choice]; tokenSymbol = choice;
  } else if (choice === 'CUSTOM') {
    const addr = customToken.value.trim();
    if (!isAddress(addr)) throw new Error("Custom ERC-20 address invalid.");
    tokenAddr = addr; tokenSymbol = "ERC20";
  }
  // decimals & symbol
  try{
    const erc20 = new ethers.Contract(tokenAddr, [
      {"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},
      {"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}
    ], provider);
    tokenDecimals = Number(await erc20.decimals());
    try{ tokenSymbol = await erc20.symbol(); }catch{}
  }catch{ tokenDecimals = 18; }
}

async function estimateChunkGas(recipients, amounts, isNative){
  try{
    if (isNative){
      const total = amounts.reduce((s,x)=>s + x, 0n);
      const fee = await bulk.quoteFeeOnAmount(total);
      return await bulk.sendNative.estimateGas(recipients, amounts, { value: total + fee });
    } else {
      return await bulk.sendERC20.estimateGas(tokenAddr, recipients, amounts);
    }
  }catch{ return null; }
}

function cap(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
async function pickChunkSize(recipients, amounts, isNative){
  let lo=CONFIG.GAS.minChunk, hi=Math.min(CONFIG.GAS.maxChunk, recipients.length);
  let best=Math.min(hi,100);
  while (lo<=hi){
    const mid=cap(Math.floor((lo+hi)/2), lo, hi);
    const r=recipients.slice(0,mid), a=amounts.slice(0,mid);
    const gas=await estimateChunkGas(r,a,isNative);
    if (gas && gas <= CONFIG.GAS.targetPerTx){ best=mid; lo=mid+1; } else { hi=mid-1; }
  }
  if (!best || best<CONFIG.GAS.minChunk) best=Math.min(50, recipients.length);
  return cap(best, CONFIG.GAS.minChunk, CONFIG.GAS.maxChunk);
}

btnEstimate.addEventListener('click', async ()=>{
  try{
    if (!signer) throw new Error("Connect your wallet first.");
    if (!bulk) throw new Error("Set Bulk Sender address in config and reconnect.");

    // Parse
    parsedList = [];
    const raw = manualEl.value.trim();
    if (!raw) throw new Error("No recipients found.");
    for (const line of raw.split(/\r?\n/)) {
      const t=line.trim(); if (!t || t.startsWith('#') || t.startsWith('//')) continue;
      const parts = t.split(',').map(x=>x.trim());
      if (parts.length !== 2) throw new Error(`Invalid line: "${line}" (use "address,amount")`);
      if (!isAddress(parts[0])) throw new Error(`Invalid address: ${parts[0]}`);
      if (!/^\d+(\.\d+)?$/.test(parts[1])) throw new Error(`Invalid amount: ${parts[1]}`);
      parsedList.push({ addr: parts[0], amountDecimalStr: parts[1] });
    }

    await resolveToken();

    const recipients = parsedList.map(x=>x.addr);
    const amounts    = parsedList.map(x=>toUnits(x.amountDecimalStr, tokenDecimals));
    const total      = sumBig(amounts);
    const isNative   = !tokenAddr;

    const fee = await bulk.quoteFeeOnAmount(total);
    const humanTotal = isNative?ethers.formatEther(total):ethers.formatUnits(total, tokenDecimals);
    const humanFee   = isNative?ethers.formatEther(fee)  :ethers.formatUnits(fee, tokenDecimals);
    log(`Totals → amount: ${humanTotal} ${isNative?'XPL':tokenSymbol} | fee: ${humanFee} ${isNative?'XPL':tokenSymbol}`);

    // HARD BALANCE CHECKS
    if (isNative){
      const bal = await provider.getBalance(await signer.getAddress());
      if (bal < (total + fee)) {
        throw new Error(`You don't have enough XPL. Needed ${ethers.formatEther(total+fee)} XPL, balance ${ethers.formatEther(bal)} XPL.`);
      }
    } else {
      const erc20 = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
      const me = await signer.getAddress();
      const bal = await erc20.balanceOf(me);
      const needed = total + fee;
      if (bal < needed) {
        throw new Error(`You don't have enough ${tokenSymbol}. Needed ${ethers.formatUnits(needed, tokenDecimals)} ${tokenSymbol}, balance ${ethers.formatUnits(bal, tokenDecimals)} ${tokenSymbol}.`);
      }
    }

    const chunkSize = await pickChunkSize(recipients, amounts, isNative);
    log(`Validation OK: ${recipients.length} recipients | Token=${isNative?"XPL (native)":tokenSymbol} | Decimals=${tokenDecimals}`);
    log(`Auto-chunking: ${chunkSize} recipients/tx (target gas ~${CONFIG.GAS.targetPerTx})`);
    btnSend.disabled = false;
    btnSend.dataset.chunkSize = String(chunkSize);
    setStatus("Ready to send","ok");
  }catch(e){
    btnSend.disabled = true;
    setStatus(`Validation error: ${e.message || e}`, "err");
    log(`ERROR (Estimate): ${e.message || e}`, "err");
  }
});

btnSend.addEventListener('click', async ()=>{
  try{
    if (!signer || !bulk) throw new Error("Not connected / contract missing.");
    await resolveToken();

    const recipients = parsedList.map(x=>x.addr);
    const amounts    = parsedList.map(x=>toUnits(x.amountDecimalStr, tokenDecimals));
    const total      = sumBig(amounts);
    const isNative   = !tokenAddr;
    const chunkSize  = Math.max(CONFIG.GAS.minChunk, parseInt(btnSend.dataset.chunkSize || "80", 10));
    const chunksR = chunkArray(recipients, chunkSize);
    const chunksA = chunkArray(amounts, chunkSize);

    if (isNative){
      for (let i=0;i<chunksR.length;i++){
        const r=chunksR[i], a=chunksA[i];
        const subtotal = a.reduce((s,x)=>s + x, 0n);
        const fee      = await bulk.quoteFeeOnAmount(subtotal);

        const bal = await provider.getBalance(await signer.getAddress());
        if (bal < (subtotal + fee)) {
          throw new Error(`Insufficient XPL for chunk ${i+1}/${chunksR.length}. Needed ${ethers.formatEther(subtotal+fee)} XPL, balance ${ethers.formatEther(bal)} XPL.`);
        }

        log(`Sending native chunk ${i+1}/${chunksR.length} … need value=${ethers.formatEther(subtotal+fee)} XPL`);
        const tx = await bulk.sendNative(r, a, { value: subtotal + fee });
        log(`Tx sent: ${tx.hash}`); await tx.wait(); log(`Tx confirmed ✅`);
      }
    } else {
      const useAllow = !!allowFailuresEl.checked;
      const erc20 = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
      const me = await signer.getAddress();

      if (useAllow){
        const feeMax = await bulk.quoteFeeOnAmount(total);
        const needed = total + feeMax;

        const bal = await erc20.balanceOf(me);
        if (bal < needed) {
          throw new Error(`You don't have enough ${tokenSymbol}. Needed ${ethers.formatUnits(needed, tokenDecimals)} ${tokenSymbol}, balance ${ethers.formatUnits(bal, tokenDecimals)} ${tokenSymbol}.`);
        }

        const curr = await erc20.allowance(me, CONFIG.CONTRACT.bulkSender);
        if (curr < needed) {
          const delta = needed - curr;
          log(`Approving additional ${ethers.formatUnits(delta, tokenDecimals)} ${tokenSymbol} (allow-failures)…`);
          const txA = await erc20.approve(CONFIG.CONTRACT.bulkSender, needed);
          await txA.wait(); log(`Approve confirmed: ${txA.hash}`);
        } else {
          log(`Allowance OK: ${ethers.formatUnits(curr, tokenDecimals)} ${tokenSymbol}`);
        }

        log(`Sending ERC-20 (allow failures) batch of ${recipients.length} …`);
        const tx = await bulk.sendERC20AllowFailures(tokenAddr, recipients, amounts);
        log(`Tx sent: ${tx.hash}`); await tx.wait(); log(`Tx confirmed ✅ (refunds handled on-chain)`);
      } else {
        const fee = await bulk.quoteFeeOnAmount(total);
        const needed = total + fee;

        const bal = await erc20.balanceOf(me);
        if (bal < needed) {
          throw new Error(`You don't have enough ${tokenSymbol}. Needed ${ethers.formatUnits(needed, tokenDecimals)} ${tokenSymbol}, balance ${ethers.formatUnits(bal, tokenDecimals)} ${tokenSymbol}.`);
        }

        const curr = await erc20.allowance(me, CONFIG.CONTRACT.bulkSender);
        if (curr < needed) {
          const delta = needed - curr;
          log(`Approving additional ${ethers.formatUnits(delta, tokenDecimals)} ${tokenSymbol} (atomic)…`);
          const txA = await erc20.approve(CONFIG.CONTRACT.bulkSender, needed);
          await txA.wait(); log(`Approve confirmed: ${txA.hash}`);
        } else {
          log(`Allowance OK: ${ethers.formatUnits(curr, tokenDecimals)} ${tokenSymbol}`);
        }

        for (let i=0;i<chunksR.length;i++){
          const r=chunksR[i], a=chunksA[i];
          log(`Sending ERC-20 chunk ${i+1}/${chunksR.length} (${r.length} recipients)…`);
          const tx = await bulk.sendERC20(tokenAddr, r, a);
          log(`Tx sent: ${tx.hash}`); await tx.wait(); log(`Tx confirmed ✅`);
        }
      }
    }
    setStatus("Done","ok");
    log("All done ✅✅✅");
  }catch(e){
    setStatus(`Send error: ${e.message || e}`, "err");
    log(`ERROR (Send): ${e.message || e}`, "err");
  }
});

btnClear.addEventListener('click', ()=>{
  manualEl.value="";
  csvFile.value="";
  csvName.textContent="No file";
  btnSend.disabled=true;
  logEl.textContent="Ready.";
  log("Reset.");
});
</script>
</body>
</html>
